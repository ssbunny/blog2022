# Rust ç”Ÿå‘½å‘¨æœŸçš„å¸¸è§è¯¯åŒº

è¿™ç¯‡æ–‡ç« å†™å¾—å¾ˆå¥½ï¼Œç½‘ä¸Šä¹Ÿæœ‰è¯¸å¤šè¯‘æ–‡ã€‚ä¹‹æ‰€ä»¥å†è¯‘ä¸€æ¬¡ï¼Œæ˜¯å› ä¸ºæˆ‘å¯¹è¿™äº›è¯‘æ–‡çš„è´¨é‡ä¸å¤ªæ»¡æ„ã€‚å®ƒä»¬å¤§å¤šè¿‡äºæ‹—å£ï¼Œè¯‘æ–‡æ— æ³•çªå‡ºåŸæ–‡æ‰€è¡¨è¾¾çš„é‡ç‚¹ï¼Œæœ‰äº›ç”šè‡³å­˜åœ¨é”™è¯‘ã€‚æˆ‘è°¨æ…åœ°å†è¯‘ä¸€æ¬¡ï¼Œåªä¸ºåˆ†äº«ç»™ä½ ã€‚

## å¯¼è¨€

æ¥ä¸‹æ¥è¦è®²çš„è¿™äº›è¯¯åŒºæˆ‘éƒ½æ›¾é™·å…¥è¿‡ï¼Œå¦‚ä»Šä¹Ÿçœ‹åˆ°è®¸å¤šåˆå­¦è€…åœ¨å…¶ä¸­æŒ£æ‰ã€‚å¯èƒ½æˆ‘ä½¿ç”¨çš„æœ¯è¯­ä¸å¤Ÿæ ‡å‡†ï¼Œæ‰€ä»¥æˆ‘åˆ—äº†ä¸ªçŸ­è¯­é€Ÿè®°è¡¨ï¼Œä»¥é˜è¿°æˆ‘æƒ³è¡¨è¾¾çš„æ„æ€ã€‚

| çŸ­è¯­ | å«ä¹‰ |
|-|-|
| `T` | 1) ä¸€ä¸ªé›†åˆï¼ŒåŒ…å«æ‰€æœ‰å¯èƒ½çš„ç±»å‹ _æˆ–_<br>2) è¯¥é›†åˆä¸­çš„æŸä¸ªç±»å‹ |
| æ‹¥æœ‰æ‰€æœ‰æƒçš„ç±»å‹ | ä¸€äº›éå¼•ç”¨ç±»å‹ï¼Œåƒæ˜¯ `i32`, `String`, `Vec` ç­‰ |
| 1) å€Ÿç”¨ç±»å‹ _æˆ–_<br>2) å¼•ç”¨ç±»å‹ | ä¸€äº›å¼•ç”¨ç±»å‹ï¼Œæ— è®ºå¯å˜æ€§å¦‚ä½•ï¼Œåƒæ˜¯ `&i32`, `&mut i32` ç­‰ |
| 1) å¯å˜å¼•ç”¨ _æˆ–_<br>2) ç‹¬å å¼•ç”¨ | ç‹¬å å¯å˜å¼•ç”¨ï¼Œå¦‚ `&mut T` |
| 1) ä¸å¯å˜å¼•ç”¨ _æˆ–_<br>2) å…±äº«å¼•ç”¨ | å…±äº«ä¸å¯å˜å¼•ç”¨ï¼Œå¦‚ `&T` |

## è¯¯åŒº

ä¸€è¨€ä»¥è”½ä¹‹ï¼š å˜é‡çš„ç”Ÿå‘½å‘¨æœŸæ˜¯æŒ‡ç¼–è¯‘å™¨å¯é™æ€éªŒè¯å˜é‡æŒ‡å‘çš„æ•°æ®ï¼Œåœ¨å…¶å½“å‰å†…å­˜åœ°å€çš„æœ‰æ•ˆæ—¶é—´ã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘å°†ç”¨å¤§çº¦ 6500 å­—ï¼ˆè‹±æ–‡åŸæ–‡ï¼‰çš„ç¯‡å¹…è¯¦ç»†ä»‹ç»å¤§å®¶é€šå¸¸ä¼šæ··æ·†çš„åœ°æ–¹ã€‚

### 1) `T` ä»…åŒ…å«æ‹¥æœ‰æ‰€æœ‰æƒçš„ç±»å‹

è¿™ä¸€è¯¯åŒºæ›´å¤šæºè‡ªå¯¹æ³›å‹çš„é”™è¯¯ç†è§£ï¼Œè€Œéç”Ÿå‘½å‘¨æœŸã€‚ä½†åœ¨ Rust ä¸­ï¼Œæ³›å‹å’Œç”Ÿå‘½å‘¨æœŸæ˜¯ç´§å¯†ç›¸è¿çš„ï¼Œè°ˆè®ºå…¶ä¸­ä¹‹ä¸€æ—¶ä¸å¯èƒ½è§„é¿å¦ä¸€ä¸ªä¸è°ˆã€‚è¿™ä¹ˆè¯´å§ï¼š

å½“æˆ‘åˆšå¼€å§‹å­¦ä¹  Rust æ—¶ï¼Œæˆ‘çŸ¥é“ `i32`ã€`&i32` å’Œ `&mut i32` æ˜¯ä¸åŒçš„ç±»å‹ã€‚æˆ‘è¿˜çŸ¥é“æ³›å‹å˜é‡ `T` ä»£è¡¨ä¸€ä¸ªé›†åˆï¼Œå…¶ä¸­åŒ…å«æ‰€æœ‰å¯èƒ½çš„ç±»å‹ã€‚ç„¶è€Œï¼Œå°½ç®¡æˆ‘åˆ†åˆ«ç†è§£äº†è¿™ä¸¤ä»¶äº‹ï¼Œå´æ— æ³•å°†å®ƒä»¬æ”¾åœ¨ä¸€èµ·ç†è§£ã€‚åœ¨æˆ‘è¿™ä¸ª Rust æ–°æ‰‹çš„è„‘æµ·ä¸­ï¼Œè®¤ä¸ºæ³›å‹æ˜¯è¿™æ ·å·¥ä½œçš„ï¼š

| | | | |
|-|-|-|-|
| **ç±»å‹å˜é‡** | `T` | `&T` | `&mut T` |
| **ä¾‹å­** | `i32` | `&i32` | `&mut i32` |

`T` åŒ…å«æ‰€æœ‰æ‹¥æœ‰æ‰€æœ‰æƒçš„ç±»å‹ã€‚`&T` åŒ…å«æ‰€æœ‰ä¸å¯å˜å¼•ç”¨ç±»å‹ã€‚`&mut T` åŒ…å«æ‰€æœ‰å¯å˜å¼•ç”¨ç±»å‹ã€‚`T`ã€`&T` å’Œ `&mut T` æ˜¯äº’ä¸ç›¸äº¤çš„æœ‰é™é›†åˆã€‚æ¼‚äº®ã€ç®€å•ã€å¹²å‡€ã€å®¹æ˜“ã€ç›´è§‚ï¼Œä½†å®Œå…¨æ˜¯å¤§é”™ç‰¹é”™ã€‚äº‹å®ä¸Šï¼Œåœ¨ Rust ä¸­æ³›å‹æ˜¯è¿™æ ·å·¥ä½œçš„ï¼š

| | | | |
|-|-|-|-|
| **ç±»å‹å˜é‡** | `T` | `&T` | `&mut T` |
| **ä¾‹å­** | `i32`, `&i32`, `&mut i32`, `&&i32`, `&mut &mut i32`, ... | `&i32`, `&&i32`, `&&mut i32`, ... | `&mut i32`, `&mut &mut i32`, `&mut &i32`, ... |

å…¶å® `T`ã€`&T` å’Œ `&mut T` éƒ½æ˜¯æ— é™é›†ï¼Œå› ä¸ºå¯ä»¥æ— é™å€Ÿç”¨ä¸€ä¸ªç±»å‹ã€‚`T` æ˜¯ `&T` å’Œ `&mut T` çš„è¶…é›†ã€‚ä¸‹é¢æ˜¯å‡ ä¸ªéªŒè¯è¿™äº›æ¦‚å¿µçš„ä¾‹å­ï¼š

```rust
trait Trait {}

impl<T> Trait for T {}

impl<T> Trait for &T {} // âŒ

impl<T> Trait for &mut T {} // âŒ
```

ä¸Šè¿°ä»£ç æ— æ³•å¦‚æœŸç¼–è¯‘ï¼š

```none
error[E0119]: conflicting implementations of trait `Trait` for type `&_`:
 --> src/lib.rs:5:1
  |
3 | impl<T> Trait for T {}
  | ------------------- first implementation here
4 |
5 | impl<T> Trait for &T {}
  | ^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `&_`

error[E0119]: conflicting implementations of trait `Trait` for type `&mut _`:
 --> src/lib.rs:7:1
  |
3 | impl<T> Trait for T {}
  | ------------------- first implementation here
...
7 | impl<T> Trait for &mut T {}
  | ^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `&mut _`
```

ç¼–è¯‘å™¨ä¸å…è®¸æˆ‘ä»¬ä¸º `&T` å’Œ `&mut T` å®šä¹‰ `Trait` çš„å®ç°ï¼Œå› ä¸ºè¿™ä¼šä¸ `T` å¯¹ `Trait` çš„å®ç°å†²çªï¼Œåè€…å·²ç»åŒ…å«äº† `&T` å’Œ `&mut T`ã€‚ç”±äº `&T` å’Œ `&mut T` ä¸ç›¸äº¤ï¼Œå› æ­¤ä¸‹é¢çš„ä»£ç å¯ä»¥æŒ‰é¢„æœŸç¼–è¯‘ï¼š

```rust
trait Trait {}

impl<T> Trait for &T {} // âœ…

impl<T> Trait for &mut T {} // âœ…
```

**ä¸»è¦æ”¶è·**
- `T` æ˜¯ `&T` å’Œ `&mut T` çš„è¶…é›†
- `&T` å’Œ `&mut T` æ˜¯äº’ä¸ç›¸äº¤çš„é›†åˆ

### 2) è‹¥ `T: 'static` åˆ™ `T` å¿…é¡»åœ¨æ•´ä¸ªç¨‹åºè¿è¡ŒæœŸé—´æœ‰æ•ˆ

**è¯¯åŒºå»¶ä¼¸**
- `T: 'static` è¢«è§†ä½œ _"`T` æ‹¥æœ‰ `'static` ç”Ÿå‘½å‘¨æœŸ"_
- `&'static T` ä¸ `T: 'static` ç›¸åŒ
- è‹¥ `T: 'static` åˆ™ `T` æ˜¯ä¸å¯å˜çš„
- è‹¥ `T: 'static` åˆ™ `T` åªèƒ½åœ¨ç¼–è¯‘æœŸåˆ›å»º

å¤šæ•° Rust åˆå­¦è€…ç¬¬ä¸€æ¬¡æ¥è§¦ `'static` ç”Ÿå‘½å‘¨æœŸæ—¶ï¼Œéƒ½è§åˆ°è¿‡ç±»ä¼¼è¿™ç§ç¤ºä¾‹ä»£ç ï¼š

```rust
fn main() {
    let str_literal: &'static str = "str literal";
}
```

è¿™äº›åˆå­¦è€…ä»¬è¢«å‘ŠçŸ¥ï¼š`"str literal"` å·²è¢«ç¡¬ç¼–ç åˆ°ç¼–è¯‘åçš„äºŒè¿›åˆ¶æ–‡ä»¶ä¸­ï¼Œå¹¶ä¼šåœ¨è¿è¡ŒæœŸåŠ è½½åˆ°åªè¯»å†…å­˜åŒºï¼Œå› æ­¤å®ƒæ˜¯ä¸å¯å˜çš„ï¼Œåœ¨æ•´ä¸ªç¨‹åºè¿è¡ŒæœŸé—´éƒ½æœ‰æ•ˆï¼Œè¿™æ­£æ˜¯å®ƒä¹‹æ‰€ä»¥ç§°ä½œ `"static"` çš„åŸå› ã€‚è€Œ Rust ä½¿ç”¨ `static` å…³é”®å­—å®šä¹‰ `static` å˜é‡çš„è¯­æ³•è§„åˆ™ï¼Œæ›´æ˜¯è¿›ä¸€æ­¥å¼ºåŒ–äº†è¿™ç§è§‚å¿µã€‚

```rust
// æ³¨æ„ï¼šæœ¬ä¾‹çº¯ç²¹ç”¨äºæ¼”ç¤ºè¯´æ˜ï¼Œåˆ‡å‹¿ä½¿ç”¨ `static mut`ã€‚å®ƒæ˜¯ä¸€æŠŠåŒåˆƒå‰‘ã€‚
// åœ¨ Rust ä¸­æœ‰ safe æ¨¡å¼çš„å…¨å±€å¯å˜å•ä¾‹ï¼Œä½†è¿™ä¸åœ¨æœ¬æ–‡è®¨è®ºèŒƒå›´ã€‚

static BYTES: [u8; 3] = [1, 2, 3];
static mut MUT_BYTES: [u8; 3] = [1, 2, 3];

fn main() {
   MUT_BYTES[0] = 99; // âŒ - ä¿®æ”¹é™æ€å˜é‡æ˜¯ unsafe æ“ä½œ

    unsafe {
        MUT_BYTES[0] = 99;
        assert_eq!(99, MUT_BYTES[0]);
    }
}
```

å…³äºé™æ€å˜é‡
- å®ƒä»¬åªèƒ½åœ¨ç¼–è¯‘æ—¶åˆ›å»º
- å®ƒä»¬æ˜¯ä¸å¯å˜çš„ï¼Œæ”¹å˜å®ƒä»¬æ˜¯ä¸å®‰å…¨çš„
- å®ƒä»¬åœ¨æ•´ä¸ªç¨‹åºè¿è¡ŒæœŸé—´æœ‰æ•ˆ

`'static` ç”Ÿå‘½å‘¨æœŸå¯èƒ½å¾—åäº `static` å˜é‡çš„é»˜è®¤ç”Ÿå‘½å‘¨æœŸï¼Œæ˜¯è¿™æ ·å—ï¼Ÿå› æ­¤å¯ä»¥åˆç†åœ°è®¤ä¸ºï¼Œ`static` ç”Ÿå‘½å‘¨æœŸå¿…é¡»éµå¾ªæ‰€æœ‰ç›¸åŒçš„è§„åˆ™ï¼Œæ˜¯è¿™æ ·å—ï¼Ÿ

æ˜¯è¿™æ ·çš„ï¼Œä½†*å…·æœ‰* `'static` ç”Ÿå‘½å‘¨æœŸçš„ç±»å‹å’Œ*ç»‘å®š*äº† `'static` ç”Ÿå‘½å‘¨æœŸçš„ç±»å‹æ˜¯ä¸åŒçš„æ¦‚å¿µã€‚åè€…å¯ä»¥åœ¨è¿è¡ŒæœŸåŠ¨æ€åˆ†é…ï¼Œå¯ä»¥å®‰å…¨ã€è‡ªç”±åœ°ä¿®æ”¹ï¼Œå¯ä»¥ dropï¼Œå¯ä»¥å­˜æ´»ä»»æ„æ—¶é•¿ã€‚

åœ¨è¿™ä¸€ç‚¹ä¸Šï¼ŒåŒºåˆ† `&'static T` å’Œ `T: 'static` è‡³å…³é‡è¦ã€‚

`&'static T` æ˜¯å¯¹ `T` çš„ä¸å¯å˜å¼•ç”¨ï¼Œè¯¥å¼•ç”¨å¯ä»¥å®‰å…¨åœ°ã€æ— é™æœŸé©»ç•™åœ¨å†…å­˜ä¸­ï¼Œç”šè‡³åˆ°ç¨‹åºç»“æŸã€‚ç„¶è€Œåªæœ‰å½“ `T` æœ¬èº«æ˜¯ä¸å¯å˜çš„ï¼Œå¹¶ä¸”åœ¨*åˆ›å»ºå¼•ç”¨å*ä¸ä¼šç§»åŠ¨æ—¶ï¼Œæ‰æœ‰å¯èƒ½åšåˆ°è¿™ä¸€ç‚¹ã€‚`T` ä¸éœ€è¦åœ¨ç¼–è¯‘æœŸåˆ›å»ºã€‚å®Œå…¨å¯ä»¥åœ¨è¿è¡ŒæœŸç”Ÿæˆéšæœºçš„åŠ¨æ€åˆ†é…æ•°æ®ï¼Œå¹¶ä»¥å†…å­˜æ³„æ¼ä¸ºä»£ä»·è¿”å›å¯¹å®ƒçš„ `'static` å¼•ç”¨ï¼Œä¾‹å¦‚ï¼š

```rust
use rand;

// è¿è¡ŒæœŸéšæœºç”Ÿæˆ 'static str å¼•ç”¨
fn rand_str_generator() -> &'static str {
    let rand_string = rand::random::<u64>().to_string();
    Box::leak(rand_string.into_boxed_str())
}
```

`T: 'static` åˆ™æ˜¯æŒ‡ `T` æœ¬èº«å¯ä»¥å®‰å…¨åœ°ã€æ— é™æœŸé©»ç•™åœ¨å†…å­˜ä¸­ï¼Œç”šè‡³åˆ°ç¨‹åºç»“æŸã€‚`T: 'static` æ—¢åŒ…æ‹¬æ‰€æœ‰ `&'static T`ï¼Œä¹ŸåŒ…æ‹¬æ‰€æœ‰æ‹¥æœ‰æ‰€æœ‰æƒçš„ç±»å‹ï¼Œå¦‚ `String`ã€`Vec` ç­‰ã€‚åªè¦æ•°æ®çš„æ‰€æœ‰è€…æŒæœ‰è¿™äº›æ•°æ®ï¼Œå°±èƒ½ä¿è¯å…¶æ°¸ä¸å¤±æ•ˆï¼Œä¹Ÿå°±æ˜¯è¯´æ‰€æœ‰è€…å¯ä»¥å®‰å…¨åœ°ã€æ— é™æœŸåœ°æŒæœ‰è¿™äº›æ•°æ®ï¼Œç›´åˆ°ç¨‹åºç»“æŸã€‚`T: 'static` åº”è¢«è§†ä½œ *â€œ`T` å— `'static` ç”Ÿå‘½å‘¨æœŸçº¦æŸâ€*ï¼Œè€Œ**ä¸æ˜¯** *â€œ`T` æ‹¥æœ‰ `'static` ç”Ÿå‘½å‘¨æœŸâ€*ã€‚ç”¨ç¨‹åºæ¥è¯´æ˜è¿™ä¸€æ¦‚å¿µï¼š

```rust
use rand;

fn drop_static<T: 'static>(t: T) {
    std::mem::drop(t);
}

fn main() {
    let mut strings: Vec<String> = Vec::new();
    for _ in 0..10 {
        if rand::random() {
            // æ‰€æœ‰å­—ç¬¦ä¸²éƒ½æ˜¯éšæœºç”Ÿæˆçš„ï¼Œå¹¶åœ¨è¿è¡ŒæœŸåŠ¨æ€åˆ†é…
            let string = rand::random::<u64>().to_string();
            strings.push(string);
        }
    }

    // strings æ˜¯æ‹¥æœ‰æ‰€æœ‰æƒçš„ç±»å‹ï¼Œå› æ­¤å®ƒä»¬å— 'static çº¦æŸ
    for mut string in strings {
        // æ‰€æœ‰å­—ç¬¦ä¸²éƒ½æ˜¯å¯å˜çš„
        string.push_str("a mutation");
        // è€Œä¸”éƒ½å¯ä»¥è¢« drop
        drop_static(string); // âœ…
    }

    // åœ¨ç¨‹åºç»“æŸå‰ï¼Œstrings éƒ½å·²å¤±æ•ˆ
    println!("I am the end of the program");
}
```

**ä¸»è¦æ”¶è·**
- `T: 'static` åº”è¢«ç†è§£ä¸º _â€œ`T` å— `'static` ç”Ÿå‘½å‘¨æœŸçº¦æŸâ€_
- è‹¥ `T: 'static` åˆ™ `T` å¯ä»¥æ˜¯æ‹¥æœ‰ `'static` ç”Ÿå‘½å‘¨æœŸçš„å€Ÿç”¨ç±»å‹ _æˆ–_ æ‹¥æœ‰æ‰€æœ‰æƒçš„ç±»å‹
- æ—¢ç„¶ `T: 'static` åŒ…æ‹¬æ‹¥æœ‰æ‰€æœ‰æƒçš„ç±»å‹ï¼Œä¾¿æ„å‘³ç€ `T`
    - å¯ä»¥åœ¨è¿è¡ŒæœŸåŠ¨æ€åˆ†é…
    - ä¸å¿…åœ¨æ•´ä¸ªç¨‹åºè¿è¡ŒæœŸé—´æœ‰æ•ˆ
    - å¯ä»¥å®‰å…¨ã€è‡ªç”±åœ°ä¿®æ”¹
    - å¯ä»¥åœ¨è¿è¡ŒæœŸåŠ¨æ€ drop
    - å¯ä»¥æœ‰ä¸åŒçš„ç”Ÿå‘½å‘¨æœŸ

### 3) `&'a T` å’Œ `T: 'a` ç›¸åŒ

è¿™ä¸€è¯¯åŒºå…¶å®æ˜¯ä¸Šä¸€ä¸ªçš„æ³›åŒ–ã€‚

`&'a T` è¦æ±‚å¹¶éšå«äº† `T: 'a`ï¼Œå› ä¸ºå¦‚æœ `T` æœ¬èº«å¯¹ç”Ÿå‘½å‘¨æœŸ `'a` æ— æ•ˆï¼Œé‚£ä¹ˆç”Ÿå‘½å‘¨æœŸä¸º `'a` çš„ `T` çš„å¼•ç”¨æ›´ä¸å¯èƒ½å¯¹ `'a` æœ‰æ•ˆã€‚æ¯”æ–¹è¯´ï¼ŒRust ç¼–è¯‘å™¨ä»ä¸å…è®¸æ„é€  `&'static Ref<'a, T>` ç±»å‹ï¼Œæ­£æ˜¯å› ä¸ºå¦‚æœ `Ref` åªå¯¹ `'a` æœ‰æ•ˆï¼Œå°±ä¸å¯èƒ½å¯¹å®ƒè¿›è¡Œ `'static` å¼•ç”¨ã€‚

`Tï¼š'a` åŒ…æ‹¬æ‰€æœ‰ `&'a T`ï¼Œåä¹‹åˆ™ä¸æˆç«‹ã€‚

```rust
// åªæ¥å—æ»¡è¶³ç”Ÿå‘½å‘¨æœŸ 'a çš„å¼•ç”¨ç±»å‹
fn t_ref<'a, T: 'a>(t: &'a T) {}

// æ¥å—æ»¡è¶³ç”Ÿå‘½å‘¨æœŸ 'a çš„æ‰€æœ‰ç±»å‹
fn t_bound<'a, T: 'a>(t: T) {}

// æ‹¥æœ‰æ‰€æœ‰æƒçš„ç±»å‹ï¼Œå…¶å†…éƒ¨åŒ…å«å¼•ç”¨
struct Ref<'a, T: 'a>(&'a T);

fn main() {
    let string = String::from("string");

    t_bound(&string); // âœ…
    t_bound(Ref(&string)); // âœ…
    t_bound(&Ref(&string)); // âœ…

    t_ref(&string); // âœ…
    t_ref(Ref(&string)); // âŒ - expected ref, found struct
    t_ref(&Ref(&string)); // âœ…

    // å­—ç¬¦ä¸²å˜é‡å— 'static çº¦æŸï¼Œè€Œ 'static å— 'a çº¦æŸ
    t_bound(string); // âœ…
}
```

**ä¸»è¦æ”¶è·**
- ä¸ `&'a T` ç›¸æ¯”ï¼Œ`T: 'a` æ›´é€šç”¨ã€æ›´çµæ´»
- `T: 'a` æ¥å—æ‹¥æœ‰æ‰€æœ‰æƒçš„ç±»å‹ï¼ˆå…¶å†…éƒ¨å¯å«æœ‰å¼•ç”¨ï¼‰ã€å¼•ç”¨ç±»å‹
- `&'a T` åªæ¥å—å¼•ç”¨ç±»å‹
- è‹¥ `T: 'static` åˆ™ `T: 'a` ï¼Œå› ä¸ºå¯¹äºæ‰€æœ‰ `'a` éƒ½æœ‰ `'static` >= `'a`


### 4) æˆ‘çš„ä»£ç æ²¡ä½¿ç”¨æ³›å‹ä¹Ÿä¸å«ç”Ÿå‘½å‘¨æœŸæ³¨è§£

**è¯¯åŒºå»¶ä¼¸**
- å¯ä»¥é¿å…ä½¿ç”¨æ³›å‹å’Œç”Ÿå‘½å‘¨æœŸæ³¨è§£

è¿™ä¸€çœ‹ä¼¼ä»¤äººèˆ’é€‚çš„è¯¯åŒºç¥¸èµ·è‡ª Rust çš„ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™ï¼ˆlifetime elision rulesï¼‰ï¼Œå®ƒå…è®¸åœ¨å‡½æ•°ä¸­çœç•¥ç”Ÿå‘½å‘¨æœŸæ³¨è§£ã€‚ä¹‹æ‰€ä»¥èƒ½å¤Ÿçœç•¥ï¼Œæ˜¯å› ä¸º Rust çš„å€Ÿç”¨æ£€æŸ¥å™¨å¯ä»¥åŸºäºä»¥ä¸‹è§„åˆ™æ¨æ–­å‡ºç›¸åº”çš„æ³¨è§£ï¼š
- å‡½æ•°çš„æ¯ä¸ªè¾“å…¥å¼•ç”¨éƒ½æœ‰ä¸€ä¸ªç‹¬ç«‹çš„ç”Ÿå‘½å‘¨æœŸ
- å¦‚æœæœ‰ä¸”åªæœ‰ä¸€ä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸï¼Œè¯¥ç”Ÿå‘½å‘¨æœŸå°†åº”ç”¨äºæ‰€æœ‰è¾“å‡ºå¼•ç”¨
- å¦‚æœæœ‰å¤šä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸï¼Œä½†å…¶ä¸­ä¸€ä¸ªæ˜¯ `&self` æˆ– `&mut self`ï¼Œé‚£ä¹ˆ `self` çš„ç”Ÿå‘½å‘¨æœŸå°†åº”ç”¨äºæ‰€æœ‰è¾“å‡ºå¼•ç”¨
- å¦åˆ™ï¼Œå¿…é¡»æ˜ç¡®æŒ‡å‡ºè¾“å‡ºç”Ÿå‘½å‘¨æœŸ

[è¯‘æ³¨ï¼šå‡½æ•°æˆ–æ–¹æ³•çš„å‚æ•°çš„ç”Ÿå‘½å‘¨æœŸè¢«ç§°ä¸ºè¾“å…¥ç”Ÿå‘½å‘¨æœŸï¼ˆinput lifetimesï¼‰ï¼Œè€Œè¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸè¢«ç§°ä¸ºè¾“å‡ºç”Ÿå‘½å‘¨æœŸï¼ˆoutput lifetimesï¼‰]

è¦ç†è§£çš„æœ‰ç‚¹å¤šï¼Œä¸å¦¨æ¥çœ‹ä¸€äº›ä¾‹å­ï¼š

```rust
// çœç•¥å½¢å¼
fn print(s: &str);

// å®Œæ•´å½¢å¼
fn print<'a>(s: &'a str);

// çœç•¥å½¢å¼
fn trim(s: &str) -> &str;

// å®Œæ•´å½¢å¼
fn trim<'a>(s: &'a str) -> &'a str;

// éæ³•ï¼Œæ— æ³•ç¡®å®šè¾“å‡ºç”Ÿå‘½å‘¨æœŸï¼Œæ— è¾“å…¥
fn get_str() -> &str;

// æ˜¾å¼æ ‡æ³¨
fn get_str<'a>() -> &'a str; // æ³›å‹ç‰ˆæœ¬
fn get_str() -> &'static str; // 'static ç‰ˆæœ¬

// éæ³•ï¼Œæ— æ³•ç¡®å®šè¾“å‡ºç”Ÿå‘½å‘¨æœŸï¼Œå¤šè¾“å…¥
fn overlap(s: &str, t: &str) -> &str;

// æ˜¾å¼æ ‡æ³¨ï¼ˆä½†ä»æœ‰éƒ¨åˆ†æ ‡æ³¨è¢«çœç•¥ï¼‰
fn overlap<'a>(s: &'a str, t: &str) -> &'a str; // è¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸä¸é•¿äº s
fn overlap<'a>(s: &str, t: &'a str) -> &'a str; // è¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸä¸é•¿äº t
fn overlap<'a>(s: &'a str, t: &'a str) -> &'a str; // è¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸä¸é•¿äº s & t
fn overlap(s: &str, t: &str) -> &'static str; // è¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸå¯ä»¥é•¿äº s & t
fn overlap<'a>(s: &str, t: &str) -> &'a str; // è¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸä¸è¾“å…¥æ— å…³

// å®Œæ•´å½¢å¼
fn overlap<'a, 'b>(s: &'a str, t: &'b str) -> &'a str;
fn overlap<'a, 'b>(s: &'a str, t: &'b str) -> &'b str;
fn overlap<'a>(s: &'a str, t: &'a str) -> &'a str;
fn overlap<'a, 'b>(s: &'a str, t: &'b str) -> &'static str;
fn overlap<'a, 'b, 'c>(s: &'a str, t: &'b str) -> &'c str;

// çœç•¥å½¢å¼
fn compare(&self, s: &str) -> &str;

// å®Œæ•´å½¢å¼
fn compare<'a, 'b>(&'a self, &'b str) -> &'a str;
```

å¦‚æœä½ æ›¾å†™è¿‡
* struct æ–¹æ³•
* è·å–å¼•ç”¨çš„å‡½æ•°
* è¿”å›å¼•ç”¨çš„å‡½æ•°
* æ³›å‹å‡½æ•°
* trait å¯¹è±¡ï¼ˆç¨åè¯¦è¿°ï¼‰
* é—­åŒ…ï¼ˆç¨åè¯¦è¿°ï¼‰

é‚£ä¹ˆä½ çš„ä»£ç ä¸­å°±éå¸ƒçœç•¥çš„æ³›å‹ç”Ÿå‘½å‘¨æœŸæ³¨è§£ã€‚

**ä¸»è¦æ”¶è·**
- å‡ ä¹æ‰€æœ‰ Rust ä»£ç éƒ½æ˜¯æ³›å‹ä»£ç ï¼Œå››å¤„çš†æ˜¯çœç•¥çš„ç”Ÿå‘½å‘¨æœŸæ³¨è§£



### 5) åªè¦ç¼–è¯‘æˆåŠŸï¼Œç”Ÿå‘½å‘¨æœŸæ³¨è§£å°±æ˜¯æ­£ç¡®çš„

**è¯¯åŒºå»¶ä¼¸**
- Rust çš„å‡½æ•°ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™æ€»æ˜¯æ­£ç¡®çš„
- Rust çš„å€Ÿç”¨æ£€æŸ¥å™¨åœ¨æŠ€æœ¯ä¸Šå’Œ _è¯­ä¹‰ä¸Š_ æ€»æ˜¯æ­£ç¡®çš„
- Rust æ¯”æˆ‘æ›´äº†è§£ç¨‹åºçš„è¯­ä¹‰

Rust ç¨‹åºæœ‰å¯èƒ½åœ¨æŠ€æœ¯ä¸Šå¯ä»¥ç¼–è¯‘ï¼Œä½†åœ¨è¯­ä¹‰ä¸Šä»ç„¶æ˜¯é”™è¯¯çš„ã€‚ä¸¾ä¸ªä¾‹å­ï¼š

```rust
struct ByteIter<'a> {
    remainder: &'a [u8]
}

impl<'a> ByteIter<'a> {
    fn next(&mut self) -> Option<&u8> {
        if self.remainder.is_empty() {
            None
        } else {
            let byte = &self.remainder[0];
            self.remainder = &self.remainder[1..];
            Some(byte)
        }
    }
}

fn main() {
    let mut bytes = ByteIter { remainder: b"1" };
    assert_eq!(Some(&b'1'), bytes.next());
    assert_eq!(None, bytes.next());
}
```

`ByteIter` æ˜¯ä¸€ä¸ªç”¨æ¥è¿­ä»£å­—èŠ‚åˆ‡ç‰‡çš„è¿­ä»£å™¨ã€‚ä¸ºäº†ç®€æ´èµ·è§ï¼Œæˆ‘ä»¬è·³è¿‡äº† `Iterator` trait çš„å®ç°ã€‚ç›®å‰ä¸€åˆ‡æ­£å¸¸ï¼Œä½†å¦‚æœæˆ‘ä»¬æƒ³åŒæ—¶æŸ¥çœ‹ä¸€å¯¹å­—èŠ‚å‘¢ï¼Ÿ

```rust
fn main() {
    let mut bytes = ByteIter { remainder: b"1123" };
    let byte_1 = bytes.next();
    let byte_2 = bytes.next();
    if byte_1 == byte_2 { // âŒ
        // do something
    }
}
```

å‘¦ï¼ç¼–è¯‘é”™è¯¯ï¼š

```none
error[E0499]: cannot borrow `bytes` as mutable more than once at a time
  --> src/main.rs:20:18
   |
19 |     let byte_1 = bytes.next();
   |                  ----- first mutable borrow occurs here
20 |     let byte_2 = bytes.next();
   |                  ^^^^^ second mutable borrow occurs here
21 |     if byte_1 == byte_2 {
   |        ------ first borrow later used here
```

å¯ä»¥é€ä¸ªå¤åˆ¶å­—èŠ‚æ¥è§£å†³æ­¤ç¼–è¯‘é”™è¯¯ã€‚ç¡®å®ï¼Œåœ¨å¤„ç†å­—èŠ‚æ—¶å¤åˆ¶æ˜¯æ²¡é—®é¢˜çš„ï¼Œä½†å¦‚æœæ‰“ç®—æŠŠ `ByteIter` åšæˆä¸€ä¸ªé€šç”¨çš„åˆ‡ç‰‡è¿­ä»£å™¨ï¼Œå¯ä»¥éå†ä»»ä½• `&'a [T]`ï¼Œé‚£å°±æœ‰å¯èƒ½æŠŠå®ƒç”¨åœ¨å¤åˆ¶æˆ–å…‹éš†æˆæœ¬å¾ˆé«˜çš„ç±»å‹ä¸Šï¼Œç”šè‡³æ˜¯ä¸å¯èƒ½å¤åˆ¶æˆ–å…‹éš†çš„ç±»å‹ä¸Šã€‚å¥½å§ï¼Œæˆ‘æƒ³å’±ä»¬å¯¹æ­¤éƒ½æ— èƒ½ä¸ºåŠ›ï¼Œä»£ç èƒ½ç¼–è¯‘ï¼Œé‚£ä¹ˆç”Ÿå‘½å‘¨æœŸæ³¨è§£ä¸€å®šæ˜¯æ­£ç¡®çš„ï¼Œå¯¹å—ï¼Ÿ

ä¸å¯¹ï¼Œå½“å‰çš„ç”Ÿå‘½å‘¨æœŸæ³¨è§£å®é™…ä¸Šæ­£æ˜¯ bug çš„æ ¹æºï¼è¯¥ bug ç‰¹åˆ«éš¾ä»¥å‘ç°ï¼Œå› ä¸ºé”™è¯¯çš„ç”Ÿå‘½å‘¨æœŸæ³¨é‡Šè¢«çœç•¥æ‰äº†ã€‚æˆ‘ä»¬æ¥è¡¥å……ä¸Šè¢«çœç•¥çš„ç”Ÿå‘½å‘¨æœŸï¼Œä»¥ä¾¿æ›´æ¸…æ¥šåœ°äº†è§£é—®é¢˜æ‰€åœ¨ï¼š

```rust
struct ByteIter<'a> {
    remainder: &'a [u8]
}

impl<'a> ByteIter<'a> {
    fn next<'b>(&'b mut self) -> Option<&'b u8> {
        if self.remainder.is_empty() {
            None
        } else {
            let byte = &self.remainder[0];
            self.remainder = &self.remainder[1..];
            Some(byte)
        }
    }
}
```

ä¸€ç‚¹å¸®åŠ©éƒ½æ²¡æœ‰ï¼Œçœ‹èµ·æ¥è¿˜æ˜¯ä¸€å¤´é›¾æ°´ã€‚æ­¤å¤„æœ‰ä¸ªåªæœ‰ Rust é«˜æ‰‹æ‰çŸ¥é“çš„å°çªé—¨ï¼šç»™ç”Ÿå‘½å‘¨æœŸæ³¨è§£èµ·ä¸ªæœ‰æ„ä¹‰çš„åå­—ã€‚æ¥ï¼Œå†è¯•ä¸€æ¬¡ï¼š

```rust
struct ByteIter<'remainder> {
    remainder: &'remainder [u8]
}

impl<'remainder> ByteIter<'remainder> {
    fn next<'mut_self>(&'mut_self mut self) -> Option<&'mut_self u8> {
        if self.remainder.is_empty() {
            None
        } else {
            let byte = &self.remainder[0];
            self.remainder = &self.remainder[1..];
            Some(byte)
        }
    }
}
```

æ¯ä¸ªè¿”å›çš„å­—èŠ‚éƒ½è¢«æ³¨è§£ä¸º `'mut_self`ï¼Œä½†è¿™äº›å­—èŠ‚æ˜¾ç„¶æ¥è‡ª `'remainder` ï¼æ¥ï¼Œæå®šå®ƒã€‚

```rust
struct ByteIter<'remainder> {
    remainder: &'remainder [u8]
}

impl<'remainder> ByteIter<'remainder> {
    fn next(&mut self) -> Option<&'remainder u8> {
        if self.remainder.is_empty() {
            None
        } else {
            let byte = &self.remainder[0];
            self.remainder = &self.remainder[1..];
            Some(byte)
        }
    }
}

fn main() {
    let mut bytes = ByteIter { remainder: b"1123" };
    let byte_1 = bytes.next();
    let byte_2 = bytes.next();
    // è°ƒæ•´åç”šè‡³å¯ä»¥ drop æ‰è¿­ä»£å™¨
    std::mem::drop(bytes);
    if byte_1 == byte_2 { // âœ…
        // do something
    }
}
```

ç°åœ¨å›è¿‡å¤´æ¥çœ‹çœ‹ä¸Šä¸€ä¸ªç‰ˆæœ¬çš„ä»£ç ï¼Œæ—¢ç„¶å®ƒæ˜¯é”™è¯¯çš„ï¼ŒRust ä¸ºä»€ä¹ˆè¦ç¼–è¯‘å®ƒå‘¢ï¼ŸåŸå› å¾ˆç®€å•ï¼šå†…å­˜å®‰å…¨ã€‚

Rust å€Ÿç”¨æ£€æŸ¥å™¨åªè¦èƒ½åˆ©ç”¨ç”Ÿå‘½å‘¨æœŸæ³¨è§£é™æ€éªŒè¯ç¨‹åºçš„å†…å­˜å®‰å…¨æ€§å°±å¤Ÿäº†ï¼Œå¤šä½™çš„äº‹æƒ…æ¦‚ä¸å…³å¿ƒã€‚å³ä½¿ç”Ÿå‘½å‘¨æœŸæ³¨è§£å­˜åœ¨è¯­ä¹‰é”™è¯¯ï¼ŒRust ä¹Ÿä¹äºç¼–è¯‘å®ƒï¼Œå“ªæ€•ä¼šç»™ç¨‹åºå¸¦æ¥ä¸å¿…è¦çš„é™åˆ¶ã€‚

æ¥çœ‹ä¸€ä¸ªä¸ä¸Šé¢ç›¸åçš„ä¾‹å­ï¼šç¤ºä¾‹ä¸­ï¼ŒRust çš„ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™è¯­ä¹‰ä¸Šæ­£ç¡®ï¼Œä½†æˆ‘ä»¬å´æ— æ„ä¸­å†™å‡ºäº†ä¸€ä¸ªé™åˆ¶æä¸¥çš„æ–¹æ³•ï¼Œå¹¶ä½¿ç”¨äº†ä¸å¿…è¦çš„æ˜¾å¼ç”Ÿå‘½å‘¨æœŸæ³¨è§£ã€‚

```rust
#[derive(Debug)]
struct NumRef<'a>(&'a i32);

impl<'a> NumRef<'a> {
    // ç»“æ„ä½“çš„æ³›å‹æ˜¯ 'a ï¼Œæ˜¯å¦æ„å‘³ç€
    // ä¹Ÿéœ€è¦ç”¨ 'a æ¥æ³¨è§£ self å‚æ•°ï¼Ÿ(ç­”æ¡ˆï¼šå¦ï¼‰
    fn some_method(&'a mut self) {}
}

fn main() {
    let mut num_ref = NumRef(&5);
    // åœ¨å…¶ç”Ÿå‘½å‘¨æœŸå†…å¯å˜åœ°å€Ÿç”¨ num_ref
    num_ref.some_method();
    num_ref.some_method(); // âŒ
    println!("{:?}", num_ref); // âŒ
}
```

å½“ struct å­˜åœ¨æ³›å‹å‚æ•° `'a` æ—¶ï¼Œå‡ ä¹æ°¸è¿œä¸ä¼šå†å†™ä¸€ä¸ªæ¥æ”¶ `&'a mut self` çš„æ–¹æ³•ï¼Œå› ä¸ºè¿™æ ·å†™ç›¸å½“äºå‘Šè¯‰ Rust _"è¯¥æ–¹æ³•å°†åœ¨ struct çš„æ•´ä¸ªç”Ÿå‘½å‘¨æœŸå†…å¯å˜åœ°å€Ÿç”¨è¯¥ struct"_ã€‚å®è·µä¸­æ„å‘³ç€ Rust çš„å€Ÿç”¨æ£€æŸ¥å™¨æœ€å¤šåªå…è®¸è°ƒç”¨ `some_method` ä¸€æ¬¡ï¼Œä¹‹å struct å°±æ°¸ä¹…åœ°è¢«å¯å˜å€Ÿç”¨èµ°ï¼Œä»è€Œæ— æ³•å†ä½¿ç”¨ã€‚è¿™ç§ä½¿ç”¨åœºæ™¯æå…¶ç½•è§ï¼Œä½†å¯¹äºæ‡µæ‡‚çš„åˆå­¦è€…æ¥è¯´ï¼Œå´éå¸¸å®¹æ˜“ç¼–å†™å‡ºä¸Šé¢è¿™ç±»ä»£ç ï¼Œå…³é”®å®ƒè¿˜èƒ½ç¼–è¯‘é€šè¿‡ã€‚è§£å†³æ–¹æ³•æ˜¯ä¸å»æ·»åŠ ä¸å¿…è¦çš„æ˜¾å¼ç”Ÿå‘½å‘¨æœŸæ³¨è§£ï¼Œäº¤ç”± Rust çš„ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™å¤„ç†ï¼š

```rust
#[derive(Debug)]
struct NumRef<'a>(&'a i32);

impl<'a> NumRef<'a> {
    // mut self ä¸Šä¸å†ä½¿ç”¨ 'a
    fn some_method(&mut self) {}

    // å»æ‰è¯­æ³•ç³–åç›¸å½“äº
    fn some_method_desugared<'b>(&'b mut self){}
}

fn main() {
    let mut num_ref = NumRef(&5);
    num_ref.some_method();
    num_ref.some_method(); // âœ…
    println!("{:?}", num_ref); // âœ…
}
```

**ä¸»è¦æ”¶è·**
- Rust çš„å‡½æ•°ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™å¹¶ä¸æ€»æ˜¯é€‚ç”¨äºæ‰€æœ‰æƒ…å†µ
- Rust å¹¶ä¸æ¯”ä½ æ›´äº†è§£ç¨‹åºçš„è¯­ä¹‰
- ä¸ºç”Ÿå‘½å‘¨æœŸæ³¨è§£èµ‹äºˆæœ‰æ„ä¹‰çš„åç§°
- è°¨æ…è€ƒè™‘åœ¨ä½•å¤„æ”¾ç½®æ˜¾å¼ç”Ÿå‘½å‘¨æœŸæ³¨è§£ä»¥åŠä¸ºä»€ä¹ˆè¦è¿™æ ·åš



### 6) è£…ç®±åçš„ trait å¯¹è±¡æ²¡æœ‰ç”Ÿå‘½å‘¨æœŸ

å‰é¢æˆ‘ä»¬è®¨è®ºäº† Rust é’ˆå¯¹å‡½æ•°çš„ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™ã€‚Rust ä¹Ÿæœ‰é’ˆå¯¹ trait å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™ï¼Œå®ƒä»¬æ˜¯ï¼š
- å¦‚æœ trait å¯¹è±¡è¢«ç”¨ä½œæ³›å‹çš„ç±»å‹å‚æ•°ï¼Œé‚£ä¹ˆå®ƒçš„ç”Ÿå‘½å‘¨æœŸçº¦æŸä»åŒ…å«ç±»å‹ä¸­æ¨æ–­
    - å¦‚æœåœ¨åŒ…å«ç±»å‹ä¸­å­˜åœ¨å”¯ä¸€ä¸€ä¸ªçº¦æŸï¼Œåˆ™ä½¿ç”¨è¯¥çº¦æŸ
    - å¦‚æœåœ¨åŒ…å«ç±»å‹ä¸­å­˜åœ¨å¤šä¸ªçº¦æŸï¼Œåˆ™å¿…é¡»æŒ‡å®šæ˜¾å¼çº¦æŸ
- å¦‚æœä¸Šè¿°æƒ…å†µä¸é€‚ç”¨ï¼Œåˆ™
    - å¦‚æœ trait çš„å®šä¹‰åªæœ‰ä¸€ä¸ªç”Ÿå‘½å‘¨æœŸçº¦æŸï¼Œåˆ™ä½¿ç”¨è¯¥çº¦æŸ
    - å¦‚æœ `'static` è¢«ç”¨äºä»»ä½•ç”Ÿå‘½å‘¨æœŸçº¦æŸï¼Œåˆ™ä½¿ç”¨ `'static`
    - å¦‚æœ trait æ²¡æœ‰ç”Ÿå‘½å‘¨æœŸçº¦æŸï¼Œåˆ™åœ¨è¡¨è¾¾å¼ä¸­æ¨æ–­ç”Ÿå‘½å‘¨æœŸï¼Œå¹¶åœ¨è¡¨è¾¾å¼å¤–ä½¿ç”¨ `'static`

è¿™äº›å¬èµ·æ¥è¶…å¤æ‚ï¼Œä½†å¯ä»¥ç®€å•æ¦‚æ‹¬ä¸º _"æ ¹æ®ä¸Šä¸‹æ–‡æ¨æ–­å‡º trait å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸçº¦æŸ"_ ã€‚çœ‹å‡ ä¸ªä¾‹å­åä½ å°±ä¼šå‘ç°ï¼Œç”Ÿå‘½å‘¨æœŸçº¦æŸæ¨æ–­éå¸¸ç›´è§‚ï¼Œæ ¹æœ¬ä¸å¿…è®°ä½æ­£å¼çš„è§„åˆ™ï¼š

```rust
use std::cell::Ref;

trait Trait {}

// çœç•¥å½¢å¼
type T1 = Box<dyn Trait>;
// å®Œæ•´å½¢å¼ï¼ŒBox<T> å¯¹ T æ²¡æœ‰ç”Ÿå‘½å‘¨æœŸçº¦æŸï¼Œå› æ­¤æ¨æ–­ä¸º 'static
type T2 = Box<dyn Trait + 'static>;

// çœç•¥å½¢å¼
impl dyn Trait {}
// å®Œæ•´å½¢å¼
impl dyn Trait + 'static {}

// çœç•¥å½¢å¼
type T3<'a> = &'a dyn Trait;
// å®Œæ•´å½¢å¼ï¼Œ&'a T è¦æ±‚ T: 'aï¼Œå› æ­¤æ¨æ–­ä¸º 'a
type T4<'a> = &'a (dyn Trait + 'a);

// çœç•¥å½¢å¼
type T5<'a> = Ref<'a, dyn Trait>;
// å®Œæ•´å½¢å¼ï¼ŒRef<'a, T> è¦æ±‚ T: 'aï¼Œå› æ­¤æ¨æ–­ä¸º 'a
type T6<'a> = Ref<'a, dyn Trait + 'a>;

trait GenericTrait<'a>: 'a {}

// çœç•¥å½¢å¼
type T7<'a> = Box<dyn GenericTrait<'a>>;
// å®Œæ•´å½¢å¼
type T8<'a> = Box<dyn GenericTrait<'a> + 'a>;

// çœç•¥å½¢å¼
impl<'a> dyn GenericTrait<'a> {}
// å®Œæ•´å½¢å¼
impl<'a> dyn GenericTrait<'a> + 'a {}
```

å®ç°äº† trait çš„å…·ä½“ç±»å‹å¯ä»¥åŒ…å«å¼•ç”¨ï¼Œå› æ­¤å®ƒä»¬ä¹Ÿæœ‰ç”Ÿå‘½å‘¨æœŸçº¦æŸï¼Œç»§è€Œå®ƒä»¬å¯¹åº”çš„ trait å¯¹è±¡ä¹Ÿæœ‰ç”Ÿå‘½å‘¨æœŸçº¦æŸã€‚æ­¤å¤–ï¼Œè¿˜å¯ä»¥ç›´æ¥ä¸ºå¼•ç”¨å®ç° traitï¼Œè€Œå¼•ç”¨æ˜¾ç„¶ä¹Ÿæœ‰ç”Ÿå‘½å‘¨æœŸçº¦æŸï¼š

```rust
trait Trait {}

struct Struct {}
struct Ref<'a, T>(&'a T);

impl Trait for Struct {}
// åœ¨å¼•ç”¨ç±»å‹ä¸Šç›´æ¥å®ç° Trait
impl Trait for &Struct {}
// åœ¨åŒ…å«å¼•ç”¨çš„ç±»å‹ä¸Šå®ç° Trait
impl<'a, T> Trait for Ref<'a, T> {} 
```

æ€»ä¹‹ï¼Œè¿™ç‚¹å¾ˆå€¼å¾—å¼ºè°ƒï¼Œå› ä¸ºåˆå­¦è€…å°†å‡½æ•°ä»ä½¿ç”¨ trait å¯¹è±¡é‡æ„ä¸ºä½¿ç”¨æ³›å‹ï¼ˆæˆ–åä¹‹ï¼‰æ—¶ï¼Œç»å¸¸ä¼šæ„Ÿåˆ°å›°æƒ‘ã€‚ä»¥æ­¤ç¨‹åºä¸ºä¾‹ï¼š

```rust
use std::fmt::Display;

fn dynamic_thread_print(t: Box<dyn Display + Send>) {
    std::thread::spawn(move || {
        println!("{}", t);
    }).join();
}

fn static_thread_print<T: Display + Send>(t: T) { // âŒ
    std::thread::spawn(move || {
        println!("{}", t);
    }).join();
}
```

ç¨‹åºæŠ›å‡ºç¼–è¯‘é”™è¯¯ï¼š

```none
error[E0310]: the parameter type `T` may not live long enough
  --> src/lib.rs:10:5
   |
9  | fn static_thread_print<T: Display + Send>(t: T) {
   |                        -- help: consider adding an explicit lifetime bound...: `T: 'static +`
10 |     std::thread::spawn(move || {
   |     ^^^^^^^^^^^^^^^^^^
   |
note: ...so that the type `[closure@src/lib.rs:10:24: 12:6 t:T]` will meet its required lifetime bounds
  --> src/lib.rs:10:5
   |
10 |     std::thread::spawn(move || {
   |     ^^^^^^^^^^^^^^^^^^
```

å¥½æäº†ï¼Œç¼–è¯‘å™¨å‘ŠçŸ¥äº†å¦‚ä½•è§£å†³é—®é¢˜ï¼Œé‚£å°±æŒ‰å®ƒè¯´çš„æ¥è§£å†³ä¸€ä¸‹å§ã€‚

```rust
use std::fmt::Display;

fn dynamic_thread_print(t: Box<dyn Display + Send>) {
    std::thread::spawn(move || {
        println!("{}", t);
    }).join();
}

fn static_thread_print<T: Display + Send + 'static>(t: T) { // âœ…
    std::thread::spawn(move || {
        println!("{}", t);
    }).join();
}
```

ç°åœ¨å¯ä»¥ç¼–è¯‘äº†ï¼Œä½†è¿™ä¸¤ä¸ªå‡½æ•°æ”¾åœ¨ä¸€èµ·çœ‹æ—¶ä¼šå¾ˆåˆ«æ‰­ï¼šä¸ºä»€ä¹ˆç¬¬äºŒä¸ªå‡½æ•°éœ€è¦å¯¹ `T` è¿›è¡Œ `'static` çº¦æŸï¼Œè€Œç¬¬ä¸€ä¸ªå‡½æ•°ä¸éœ€è¦å‘¢ï¼Ÿä»¤äººè¿·æƒ‘ã€‚å…¶å® Rust ä½¿ç”¨ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™è‡ªåŠ¨åœ¨ç¬¬ä¸€ä¸ªå‡½æ•°ä¸­æ¨æ–­å‡ºäº† `'static` çº¦æŸï¼Œå› æ­¤è¿™ä¸¤ä¸ªå‡½æ•°å®é™…ä¸Šéƒ½æœ‰ `'static` çº¦æŸã€‚ä¸‹é¢æ‰æ˜¯ Rust ç¼–è¯‘å™¨çœ‹åˆ°çš„ï¼š

```rust
use std::fmt::Display;

fn dynamic_thread_print(t: Box<dyn Display + Send + 'static>) {
    std::thread::spawn(move || {
        println!("{}", t);
    }).join();
}

fn static_thread_print<T: Display + Send + 'static>(t: T) {
    std::thread::spawn(move || {
        println!("{}", t);
    }).join();
}
```

**ä¸»è¦æ”¶è·**
- æ‰€æœ‰ trait å¯¹è±¡éƒ½æœ‰éšå«çš„é»˜è®¤ç”Ÿå‘½å‘¨æœŸçº¦æŸ

### 7) ç¼–è¯‘å™¨çš„é”™è¯¯ä¿¡æ¯è¶³ä»¥æŒ‡å¯¼ä¿®å¤ç¨‹åº

**è¯¯åŒºå»¶ä¼¸**
- Rust é’ˆå¯¹ trait å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™æ€»æ˜¯æ­£ç¡®çš„
- Rust æ¯”æˆ‘æ›´äº†è§£ç¨‹åºçš„è¯­ä¹‰

è¿™ä¸€è¯¯åŒºåˆšå¥½æ˜¯å°†å‰ä¸¤ä¸ªåˆäºŒä¸ºä¸€çš„èŒƒä¾‹ï¼š

```rust
use std::fmt::Display;

fn box_displayable<T: Display>(t: T) -> Box<dyn Display> { // âŒ
    Box::new(t)
}
```

æŠ›å‡ºé”™è¯¯ï¼š

```none
error[E0310]: the parameter type `T` may not live long enough
 --> src/lib.rs:4:5
  |
3 | fn box_displayable<T: Display>(t: T) -> Box<dyn Display> {
  |                    -- help: consider adding an explicit lifetime bound...: `T: 'static +`
4 |     Box::new(t)
  |     ^^^^^^^^^^^
  |
note: ...so that the type `T` will meet its required lifetime bounds
 --> src/lib.rs:4:5
  |
4 |     Box::new(t)
  |     ^^^^^^^^^^^
```

å¥½ï¼Œæˆ‘ä»¬æ¥æŒ‰ç…§ç¼–è¯‘å™¨è¯´çš„æ–¹å¼ä¿®å¤è¯¥é—®é¢˜ï¼Œåˆ«å¿˜äº†å®ƒè‡ªåŠ¨ä¸ºè£…ç®±åçš„ trait å¯¹è±¡æ¨æ–­å‡ºäº† `'static` ç”Ÿå‘½å‘¨æœŸçº¦æŸï¼Œè€Œç¼–è¯‘å™¨æ¨èçš„è§£å†³æ–¹å¼æ­£æ˜¯åŸºäºè¿™ä¸€æœªè¯´æ˜çš„äº‹å®ï¼š

```rust
use std::fmt::Display;

fn box_displayable<T: Display + 'static>(t: T) -> Box<dyn Display> { // âœ…
    Box::new(t)
}
```

ç¨‹åºç°åœ¨å¯ä»¥ç¼–è¯‘äº†...ä½†è¿™å°±æ˜¯æˆ‘ä»¬æƒ³è¦çš„å—ï¼Ÿä¹Ÿè®¸æ˜¯ï¼Œä¹Ÿè®¸ä¸æ˜¯ã€‚ç¼–è¯‘å™¨æ²¡æœ‰æåˆ°å…¶ä»–ä¿®å¤æ–¹å¼ï¼Œä½†è¿™æ ·å…¶å®ä¹Ÿå¯ä»¥ï¼š

```rust
use std::fmt::Display;

fn box_displayable<'a, T: Display + 'a>(t: T) -> Box<dyn Display + 'a> { // âœ…
    Box::new(t)
}
```

è¯¥å‡½æ•°ä¸ä»…å…¼å®¹å‰ä¸€ç‰ˆæœ¬çš„æ‰€æœ‰å‚æ•°ï¼Œè¿˜èƒ½æ¥å—æ›´å¤šå‚æ•°ï¼ç„¶è€Œè¿™æ ·å°±æ›´å¥½å—ï¼Ÿä¹Ÿä¸ä¸€å®šï¼Œè¿™å–å†³äºç¨‹åºçš„è¦æ±‚å’Œé™åˆ¶ã€‚è¯¥ä¾‹ç•¥ä¸ºæŠ½è±¡ï¼Œå†æ¥çœ‹ä¸ªæ›´ç®€å•ã€æ›´æ˜æ˜¾çš„ä¾‹å­ï¼š

```rust
fn return_first(a: &str, b: &str) -> &str { // âŒ
    a
}
```

æŠ›å‡ºï¼š

```none
error[E0106]: missing lifetime specifier
 --> src/lib.rs:1:38
  |
1 | fn return_first(a: &str, b: &str) -> &str {
  |                    ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `a` or `b`
help: consider introducing a named lifetime parameter
  |
1 | fn return_first<'a>(a: &'a str, b: &'a str) -> &'a str {
  |                ^^^^    ^^^^^^^     ^^^^^^^     ^^^
```

é”™è¯¯ä¿¡æ¯å»ºè®®å°†è¾“å…¥ã€è¾“å‡ºæ ‡æ³¨ä¸ºç›¸åŒçš„ç”Ÿå‘½å‘¨æœŸã€‚å¦‚æœæŒ‰å®ƒè¯´çš„åšï¼Œç¨‹åºç¡®å®å¯ä»¥ç¼–è¯‘ï¼Œä½†è¯¥å‡½æ•°ä¼šè¿‡åº¦çº¦æŸè¿”å›ç±»å‹ã€‚å®é™…ä¸Šï¼Œæˆ‘ä»¬æƒ³è¦çš„æ˜¯ï¼š

```rust
fn return_first<'a>(a: &'a str, b: &str) -> &'a str { // âœ…
    a
}
```

**ä¸»è¦æ”¶è·**
- Rust é’ˆå¯¹ trait å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™å¹¶éé€‚åˆæ¯ç§æƒ…å†µ
- Rust ä¸ä¼šæ¯”ä½ æ›´äº†è§£ç¨‹åºçš„è¯­ä¹‰
- Rust ç¼–è¯‘å™¨é”™è¯¯ä¿¡æ¯æ‰€å»ºè®®çš„ä¿®å¤æ–¹æ³•å¯ä»¥ä½¿ç¨‹åºç¼–è¯‘æˆåŠŸï¼Œä½†è¿™å¹¶ä¸ç­‰åŒäºå¯ä»¥ä½¿ç¨‹åºç¼–è¯‘æˆåŠŸ _å¹¶ä¸”_ æœ€ç¬¦åˆè¦æ±‚ã€‚

### 8) ç”Ÿå‘½å‘¨æœŸå¯ä»¥åœ¨è¿è¡ŒæœŸå¢é•¿æˆ–ç¼©çŸ­

**è¯¯åŒºå»¶ä¼¸**
- å®¹å™¨ç±»å‹å¯åœ¨è¿è¡ŒæœŸäº¤æ¢å¼•ç”¨ä»¥æ”¹å˜å…¶ç”Ÿå‘½å‘¨æœŸ
- Rust å€Ÿç”¨æ£€æŸ¥å™¨å¯è¿›è¡Œé«˜çº§æ§åˆ¶æµåˆ†æ

ä»¥ä¸‹ä»£ç æ— æ³•ç¼–è¯‘ï¼š

```rust
struct Has<'lifetime> {
    lifetime: &'lifetime str,
}

fn main() {
    let long = String::from("long");
    let mut has = Has { lifetime: &long };
    assert_eq!(has.lifetime, "long");

    {
        let short = String::from("short");
        // â€œåˆ‡æ¢â€åˆ° short ç”Ÿå‘½å‘¨æœŸ
        has.lifetime = &short;
        assert_eq!(has.lifetime, "short");

        // â€œåˆ‡æ¢å›â€ long ç”Ÿå‘½å‘¨æœŸï¼ˆå…¶å®å¹¶æ²¡æœ‰ï¼‰
        has.lifetime = &long;
        assert_eq!(has.lifetime, "long");
        // `short` åœ¨æ­¤å¤„è¢« drop
    }
    // âŒ - `short` åœ¨ drop åä»å¤„äº â€œå€Ÿç”¨â€ çŠ¶æ€
    assert_eq!(has.lifetime, "long"); 
}
```

å®ƒä¼šæŠ›å‡ºï¼š

```none
error[E0597]: `short` does not live long enough
  --> src/main.rs:11:24
   |
11 |         has.lifetime = &short;
   |                        ^^^^^^ borrowed value does not live long enough
...
15 |     }
   |     - `short` dropped here while still borrowed
16 |     assert_eq!(has.lifetime, "long");
   |     --------------------------------- borrow later used here
```

æ”¹æˆä¸‹é¢è¿™æ ·ä¹Ÿæ— æ³•ç¼–è¯‘ï¼Œå®ƒä¼šæŠ›å‡ºä¸ä¸Šé¢å®Œå…¨ç›¸åŒçš„é”™è¯¯ï¼š

```rust
struct Has<'lifetime> {
    lifetime: &'lifetime str,
}

fn main() {
    let long = String::from("long");
    let mut has = Has { lifetime: &long };
    assert_eq!(has.lifetime, "long");

    // è¯¥ä»£ç å—æ°¸ä¸ä¼šæ‰§è¡Œ
    if false {
        let short = String::from("short");
        // â€œåˆ‡æ¢â€åˆ° short ç”Ÿå‘½å‘¨æœŸ
        has.lifetime = &short;
        assert_eq!(has.lifetime, "short");

        // â€œåˆ‡æ¢å›â€ long ç”Ÿå‘½å‘¨æœŸï¼ˆå…¶å®å¹¶æ²¡æœ‰ï¼‰
        has.lifetime = &long;
        assert_eq!(has.lifetime, "long");
        // `short` åœ¨æ­¤å¤„è¢« drop
    }
    // âŒ - `short` åœ¨ drop åä»å¤„äº â€œå€Ÿç”¨â€ çŠ¶æ€
    assert_eq!(has.lifetime, "long"); 
}
```

ç”Ÿå‘½å‘¨æœŸå¿…é¡»åœ¨ç¼–è¯‘æœŸè¿›è¡Œé™æ€éªŒè¯ï¼Œè€Œ Rust å€Ÿç”¨æ£€æŸ¥å™¨ä¹Ÿåªèƒ½è¿›è¡Œéå¸¸åŸºç¡€çš„æ§åˆ¶æµåˆ†æï¼Œå› æ­¤å®ƒå‡å®š `if-else` è¯­å¥å’Œ `match` è¯­å¥ä¸­çš„æ¯ä¸ªåˆ†æ”¯ä»£ç å—éƒ½å°†è¢«æ‰§è¡Œ[è¯‘æ³¨ï¼šRust ç¼–è¯‘å™¨é‡‡ç”¨äº†æµæ•æ„Ÿåˆ†æ(flow-sensitive analyses)]ï¼Œç„¶åä¸ºå˜é‡é€‰æ‹©æœ€çŸ­çš„ç”Ÿå‘½å‘¨æœŸã€‚å˜é‡çš„ç”Ÿå‘½å‘¨æœŸä¸€æ—¦è¢«ç¡®å®šï¼Œå°±ä¼š*æ°¸è¿œ*å—è¯¥ç”Ÿå‘½å‘¨æœŸçº¦æŸã€‚å˜é‡çš„ç”Ÿå‘½å‘¨æœŸåªèƒ½ç¼©çŸ­ï¼Œè€Œæ‰€æœ‰çš„ç¼©çŸ­éƒ½ä¼šåœ¨ç¼–è¯‘æœŸå†³å®šã€‚

**ä¸»è¦æ”¶è·**
- ç”Ÿå‘½å‘¨æœŸåœ¨ç¼–è¯‘æœŸè¿›è¡Œé™æ€éªŒè¯
- ç”Ÿå‘½å‘¨æœŸä¸èƒ½åœ¨è¿è¡ŒæœŸä»¥ä»»ä½•æ–¹å¼å¢é•¿ã€ç¼©çŸ­æˆ–æ”¹å˜
- Rust å€Ÿç”¨æ£€æŸ¥å™¨æ€»æ˜¯å‡å®šæ‰€æœ‰ä»£ç è·¯å¾„éƒ½ä¼šè¢«æ‰§è¡Œï¼Œç„¶åä¸ºå˜é‡é€‰æ‹©æœ€çŸ­çš„ç”Ÿå‘½å‘¨æœŸ

### 9) å°†å¯å˜å¼•ç”¨é™çº§ä¸ºå…±äº«å¼•ç”¨æ˜¯å®‰å…¨æ“ä½œ

**è¯¯åŒºå»¶ä¼¸**
- é‡æ–°å€Ÿç”¨å¼•ç”¨ä¼šç»“æŸå…¶åŸæœ‰ç”Ÿå‘½å‘¨æœŸï¼Œå¹¶å¼€å§‹æ–°çš„ç”Ÿå‘½å‘¨æœŸ

å¯ä»¥å°†å¯å˜å¼•ç”¨ä¼ é€’ç»™æœŸæœ›ä½¿ç”¨å…±äº«å¼•ç”¨çš„å‡½æ•°ï¼ŒRust ä¼šéšå¼åœ°é‡æ–°å€Ÿç”¨å¯å˜å¼•ç”¨ï¼Œå¹¶å°†å…¶è§†ä¸ºä¸å¯å˜ï¼š

```rust
fn takes_shared_ref(n: &i32) {}

fn main() {
    let mut a = 10;
    takes_shared_ref(&mut a); // âœ…
    takes_shared_ref(&*(&mut a)); // ä¸Šè¡Œä»£ç å»æ‰è¯­æ³•ç³–å
}
```

ç›´è§‰ä¸Šè¿™ä¹Ÿæ²¡é—®é¢˜ï¼Œæ¯•ç«Ÿé‡æ–°å€Ÿç”¨ä¸€ä¸ªå¯å˜å¼•ç”¨å¹¶å°†å…¶è§†ä¸ºä¸å¯å˜çš„ï¼Œæ²¡ä»€ä¹ˆæ¯›ç—…ï¼Œå¯¹å§ï¼Ÿä»¤äººæƒŠè®¶çš„æ˜¯ï¼Œæƒ…å†µå¹¶éå¦‚æ­¤ï¼Œä¸‹é¢çš„ç¨‹åºæ— æ³•ç¼–è¯‘ï¼š

```rust
fn main() {
    let mut a = 10;
    let b: &i32 = &*(&mut a); // é‡æ–°å€Ÿç”¨ä¸ºä¸å¯å˜å¼•ç”¨
    let c: &i32 = &a;
    dbg!(b, c); // âŒ
}
```

æŠ›å‡ºé”™è¯¯ï¼š

```none
error[E0502]: cannot borrow `a` as immutable because it is also borrowed as mutable
 --> src/main.rs:4:19
  |
3 |     let b: &i32 = &*(&mut a);
  |                     -------- mutable borrow occurs here
4 |     let c: &i32 = &a;
  |                   ^^ immutable borrow occurs here
5 |     dbg!(b, c);
  |          - mutable borrow later used here
```

å¯å˜å€Ÿç”¨ç¡®å®å‘ç”Ÿäº†ï¼Œä½†å®ƒä¼šè¢«ç«‹å³æ— æ¡ä»¶åœ°é‡æ–°å€Ÿç”¨ä¸ºä¸å¯å˜çš„ï¼Œç»§è€Œè¢« drop æ‰ã€‚ä¸ºä»€ä¹ˆ Rust ä¼šæŠŠâ€œä¸å¯å˜çš„é‡æ–°å€Ÿç”¨â€è§†ä½œâ€œä»å…·æœ‰å¯å˜å¼•ç”¨â€çš„ç‹¬å ç”Ÿå‘½å‘¨æœŸå‘¢ï¼Ÿä¸Šä¾‹è™½æ²¡æœ‰é—®é¢˜ï¼Œä½†å…è®¸å°†å¯å˜å¼•ç”¨é™çº§ä¸ºå…±äº«å¼•ç”¨ç¡®å®ä¼šå¸¦æ¥æ½œåœ¨çš„å†…å­˜å®‰å…¨é—®é¢˜ï¼š

```rust
use std::sync::Mutex;

struct Struct {
    mutex: Mutex<String>
}

impl Struct {
    // å°†å¯å˜å¼•ç”¨ self é™çº§ä¸ºå…±äº«å¼•ç”¨ str
    fn get_string(&mut self) -> &str {
        self.mutex.get_mut().unwrap()
    }
    fn mutate_string(&self) {
        // å¦‚æœ Rust å…è®¸å°†å¯å˜å¼•ç”¨é™çº§ä¸ºå…±äº«å¼•ç”¨ï¼Œé‚£ä¹ˆä¸‹é¢ä¸€è¡Œ
        // å°†ä½¿ get_string æ–¹æ³•è¿”å›çš„ä»»ä½•å…±äº«å¼•ç”¨éƒ½å¤±æ•ˆ
        *self.mutex.lock().unwrap() = "surprise!".to_owned();
    }
}

fn main() {
    let mut s = Struct {
        mutex: Mutex::new("string".to_owned())
    };
    // å¯å˜å¼•ç”¨é™çº§ä¸ºå…±äº«å¼•ç”¨
    let str_ref = s.get_string(); 
    // str_ref å·²å¤±æ•ˆï¼Œæˆäº†ä¸ªæ‚¬å‚æŒ‡é’ˆ
    s.mutate_string(); 
    dbg!(str_ref); // âŒ - ä¸€å¦‚æ‰€æ–™ï¼
}
```

è¿™é‡Œçš„é‡ç‚¹æ˜¯ï¼Œé‡æ–°å°†å¯å˜å¼•ç”¨å€Ÿç”¨ä¸ºå…±äº«å¼•ç”¨ï¼Œå¹¶ä¸èƒ½é¡ºåˆ©åœ°è·å¾—å…±äº«å¼•ç”¨ï¼šå³ä½¿å¯å˜å¼•ç”¨æœ¬èº«å·²è¢« dropï¼Œå®ƒä¹Ÿä¼šåœ¨é‡æ–°å€Ÿç”¨æœŸé—´å»¶é•¿å¯å˜å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸã€‚ä½¿ç”¨é‡æ–°å€Ÿç”¨çš„å…±äº«å¼•ç”¨éå¸¸å›°éš¾ï¼Œå°½ç®¡å®ƒæ˜¯ä¸å¯å˜çš„ï¼Œä½†å®ƒä¸èƒ½ä¸ä»»ä½•å…¶ä»–å…±äº«å¼•ç”¨é‡å [è¯‘æ³¨ï¼šå³ï¼Œä¸èƒ½ä¸å…¶ä»–å¼•ç”¨åŒæ—¶è®¿é—®ç›¸åŒçš„èµ„æº]ã€‚é‡æ–°å€Ÿç”¨çš„å…±äº«å¼•ç”¨æ—¢æœ‰å¯å˜å¼•ç”¨çš„æ‰€æœ‰ç¼ºç‚¹ï¼Œä¹Ÿæœ‰å…±äº«å¼•ç”¨çš„æ‰€æœ‰ç¼ºç‚¹ï¼Œè€Œä¸”è¿˜ä¸å…·å¤‡ä¸¤è€…çš„ä¼˜ç‚¹ã€‚æ‰€ä»¥æˆ‘è®¤ä¸ºï¼Œâ€œé‡æ–°å°†å¯å˜å¼•ç”¨å€Ÿç”¨ä¸ºå…±äº«å¼•ç”¨â€åº”è¢«è§†ä¸º Rust çš„åæ¨¡å¼ã€‚æ„è¯†åˆ°è¿™ç§åæ¨¡å¼å¾ˆé‡è¦ï¼Œè¿™æ ·å½“ä½ çœ‹åˆ°ç±»ä¼¼ä»£ç æ—¶å°±èƒ½å¾ˆå¿«è¾¨åˆ«å®ƒï¼š

```rust
// å°†å¯å˜å¼•ç”¨ T é™çº§ä¸ºå…±äº«å¼•ç”¨ T
fn some_function<T>(some_arg: &mut T) -> &T;

struct Struct;

impl Struct {
    // å°†å¯å˜å¼•ç”¨ self é™çº§ä¸ºå…±äº«å¼•ç”¨ self
    fn some_method(&mut self) -> &Self;

    // å°†å¯å˜å¼•ç”¨ self é™çº§ä¸ºå…±äº«å¼•ç”¨ T
    fn other_method(&mut self) -> &T;
}
```

å³ä¾¿åœ¨å‡½æ•°æˆ–æ–¹æ³•ç­¾åä¸­é¿å…äº†é‡æ–°å€Ÿç”¨ï¼ŒRust ä»ä¼šè‡ªåŠ¨è¿›è¡Œéšå¼çš„é‡æ–°å€Ÿç”¨ï¼Œå› æ­¤å¾ˆå®¹æ˜“åœ¨ä¸çŸ¥æƒ…çš„æƒ…å†µä¸‹é‡åˆ°é—®é¢˜ï¼Œä¾‹å¦‚ï¼š

```rust
use std::collections::HashMap;

type PlayerID = i32;

#[derive(Debug, Default)]
struct Player {
    score: i32,
}

fn start_game(player_a: PlayerID, player_b: PlayerID, server: &mut HashMap<PlayerID, Player>) {
    // ä» server è·å– playerï¼Œè‹¥æ— ï¼Œåˆ™åˆ›å»ºå¹¶æ’å…¥æ–° player
    let player_a: &Player = server.entry(player_a).or_default();
    let player_b: &Player = server.entry(player_b).or_default();

    // å¯¹ player è¿›è¡ŒæŸäº›æ“ä½œ
    dbg!(player_a, player_b); // âŒ
}
```

ä¸Šè¿°ä»£ç ç¼–è¯‘å¤±è´¥ã€‚ç”±äºæˆ‘ä»¬æ˜¾å¼åœ°æ ‡æ³¨äº†æ•°æ®ç±»å‹ï¼ŒRust ä¼šéšå¼åœ°å°† `or_default()` è¿”å›çš„ `&mut Player` é‡æ–°å€Ÿç”¨ä¸º `&Player`ã€‚ä¸ºäº†è¾¾æˆç›®çš„ï¼Œæˆ‘ä»¬å¿…é¡»ï¼š

```rust
use std::collections::HashMap;

type PlayerID = i32;

#[derive(Debug, Default)]
struct Player {
    score: i32,
}

fn start_game(player_a: PlayerID, player_b: PlayerID, server: &mut HashMap<PlayerID, Player>) {
    // ä¸¢å¼ƒæ‰€æœ‰è¿”å›çš„ Player å¯å˜å¼•ç”¨ï¼Œåæ­£ä¹Ÿä¸èƒ½åŒæ—¶ä½¿ç”¨å®ƒä»¬
    server.entry(player_a).or_default();
    server.entry(player_b).or_default();

    // è¿™æ¬¡ä»¥ä¸å¯å˜æ–¹å¼å†æ¬¡è·å– playerï¼Œè€Œä¸ä¼šæœ‰ä»»ä½•éšå¼çš„é‡æ–°å€Ÿç”¨ã€‚
    let player_a = server.get(&player_a);
    let player_b = server.get(&player_b);

    // å¯¹ player è¿›è¡ŒæŸäº›æ“ä½œ
    dbg!(player_a, player_b); // âœ…
}
```

è™½ç„¶æœ‰äº›æ‹™åŠ£ï¼Œè€Œä¸”ä¸å¤Ÿä¼˜é›…ï¼Œä½†è¿™æ˜¯æˆ‘ä»¬ç»™â€œå†…å­˜å®‰å…¨ç¥­å›â€çŒ®ä¸Šçš„ç¥­å“ã€‚

**ä¸»è¦æ”¶è·**
- å°½é‡é¿å…å°†å¯å˜å¼•ç”¨é‡æ–°å€Ÿç”¨ä¸ºå…±äº«å¼•ç”¨ï¼Œå¦åˆ™ä¼šè®©ä½ å¤´å¤§
- é‡æ–°å€Ÿç”¨å¯å˜å¼•ç”¨ä¸ä¼šç»“æŸå…¶ç”Ÿå‘½å‘¨æœŸï¼Œå³ä½¿è¯¥å¼•ç”¨å·²è¢« drop æ‰

### 10) é—­åŒ…éµå¾ªä¸å‡½æ•°ç›¸åŒçš„ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™

è¿™æ¡æ›´åƒæ˜¯ Rust ä¸­çš„ä¸€ä¸ªé™·é˜±ï¼Œè€Œä¸æ˜¯è¯¯åŒºã€‚

é—­åŒ…ï¼Œå°½ç®¡ä¹Ÿæ˜¯å‡½æ•°ï¼Œä½†å¹¶ä¸éµå¾ªä¸å‡½æ•°ç›¸åŒçš„ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™ã€‚

```rust
fn function(x: &i32) -> &i32 {
    x
}

fn main() {
    let closure = |x: &i32| x; // âŒ
}
```

æŠ›å‡º:

```none
error: lifetime may not live long enough
 --> src/main.rs:6:29
  |
6 |     let closure = |x: &i32| x;
  |                       -   - ^ returning this value requires that `'1` must outlive `'2`
  |                       |   |
  |                       |   return type of closure is &'2 i32
  |                       let's call the lifetime of this reference `'1`
```

ï¼ˆå°†çœç•¥è§„åˆ™ï¼‰å±•å¼€åå¾—åˆ°ï¼š

```rust
// è¾“å…¥ç”Ÿå‘½å‘¨æœŸåŒæ—¶åº”ç”¨äºè¾“å‡º
fn function<'a>(x: &'a i32) -> &'a i32 {
    x
}

fn main() {
    // è¾“å…¥å’Œè¾“å‡ºå„è‡ªå…·æœ‰ç‹¬ç«‹çš„ç”Ÿå‘½å‘¨æœŸ
    let closure = for<'a, 'b> |x: &'a i32| -> &'b i32 { x };
    // æ³¨æ„ï¼šä¸Šè¡Œä¸æ˜¯æœ‰æ•ˆçš„è¯­æ³•ï¼Œåªæ˜¯ç”¨å®ƒæ¥è¯´æ˜é—®é¢˜
}
```

é€ æˆè¿™ç§å·®å¼‚çš„åŸå› æŒºè’è°¬çš„ã€‚é—­åŒ…åœ¨æœ€ä¸€å¼€å§‹æ—¶ä¾¿ä½¿ç”¨äº†ä¸å‡½æ•°ä¸åŒçš„ç±»å‹æ¨æ–­è¯­ä¹‰ï¼Œè€Œç°ä»Šæˆ‘ä»¬æ°¸è¿œéƒ½åªèƒ½å¦‚æ­¤äº†ï¼Œå› ä¸ºæ­¤æ—¶å†ç»Ÿä¸€å®ƒä»¬å°†æ˜¯ä¸ªä¸å…¼å®¹çš„æ”¹å˜ã€‚é‚£ä¹ˆè¯¥å¦‚ä½•æ˜¾å¼æ ‡æ³¨é—­åŒ…çš„ç±»å‹å‘¢ï¼Ÿå¯é€‰é¡¹æœ‰ï¼š

```rust
fn main() {
    // è½¬æ¢ä¸º trait å¯¹è±¡ï¼Œå˜æˆ unsizedï¼Œå‘ƒï¼Œå¯èƒ½å¯¼è‡´ç¼–è¯‘é”™è¯¯
    let identity: dyn Fn(&i32) -> &i32 = |x: &i32| x;

    // å¯ä»¥å°†å…¶åˆ†é…åˆ°å †ä¸Šï¼Œå€’ä¹Ÿç®—ä¸ªç¬¨æ–¹æ³•
    let identity: Box<dyn Fn(&i32) -> &i32> = Box::new(|x: &i32| x);

    // å¯ä»¥è·³è¿‡åˆ†é…è¿‡ç¨‹ï¼Œç›´æ¥åˆ›å»ºä¸€ä¸ªé™æ€å¼•ç”¨
    let identity: &dyn Fn(&i32) -> &i32 = &|x: &i32| x;

    // å°†ä¸Šä¸€è¡Œå±•å¼€ :)
    let identity: &'static (dyn for<'a> Fn(&'a i32) -> &'a i32 + 'static) = &|x: &i32| -> &i32 { x };

    // è¿™æ ·åšä¼¼ä¹æ›´ç†æƒ³ï¼Œä½†å®ƒæ˜¯æ— æ•ˆè¯­æ³•
    let identity: impl Fn(&i32) -> &i32 = |x: &i32| x;

    // è¿™æ ·åšä¹Ÿå¾ˆå¥½ï¼Œä½†åŒæ ·æ˜¯æ— æ•ˆè¯­æ³•
    let identity = for<'a> |x: &'a i32| -> &'a i32 { x };

    // é‰´äº "impl trait" åœ¨å‡½æ•°è¿”å›å€¼å¤„æœ‰æ•ˆ
    fn return_identity() -> impl Fn(&i32) -> &i32 {
        |x| x
    }
    let identity = return_identity();

    // å‰ä¸€è§£å†³æ–¹æ¡ˆæ›´é€šç”¨çš„ç‰ˆæœ¬
    fn annotate<T, F>(f: F) -> F where F: Fn(&T) -> &T {
        f
    }
    let identity = annotate(|x: &i32| x);
}
```

ä»ä¸Šé¢çš„ç¤ºä¾‹ä¸­å¯ä»¥çœ‹å‡ºï¼Œå½“é—­åŒ…ç±»å‹ç”¨ä½œ trait çº¦æŸæ—¶ï¼Œå®ƒä»¬ç¡®å®éµå¾ªå¸¸è§„çš„å‡½æ•°ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™ã€‚

å…³äºè¿™ä¸€æ¡æ²¡æœ‰ä»€ä¹ˆç»éªŒæ•™è®­æˆ–å¯ç¤ºäº†ï¼Œäº‹æƒ…å°±æ˜¯è¿™æ ·ã€‚

**ä¸»è¦æ”¶è·**
- æ¯ç§è¯­è¨€çš†æœ‰é™·é˜± ğŸ¤·


## ç»“è®º

- `T` æ˜¯ `&T` å’Œ `&mut T` çš„è¶…é›†
- `&T` å’Œ `&mut T` æ˜¯äº’ä¸ç›¸äº¤çš„é›†åˆ
- `T: 'static` åº”è¢«ç†è§£ä¸º _â€œ`T` å— `'static` ç”Ÿå‘½å‘¨æœŸçº¦æŸâ€_
- è‹¥ `T: 'static` åˆ™ `T` å¯ä»¥æ˜¯æ‹¥æœ‰ `'static` ç”Ÿå‘½å‘¨æœŸçš„å€Ÿç”¨ç±»å‹ _æˆ–_ æ‹¥æœ‰æ‰€æœ‰æƒçš„ç±»å‹
- æ—¢ç„¶ `T: 'static` åŒ…æ‹¬æ‹¥æœ‰æ‰€æœ‰æƒçš„ç±»å‹ï¼Œä¾¿æ„å‘³ç€ `T`
    - å¯ä»¥åœ¨è¿è¡ŒæœŸåŠ¨æ€åˆ†é…
    - ä¸å¿…åœ¨æ•´ä¸ªç¨‹åºè¿è¡ŒæœŸé—´æœ‰æ•ˆ
    - å¯ä»¥å®‰å…¨ã€è‡ªç”±åœ°ä¿®æ”¹
    - å¯ä»¥åœ¨è¿è¡ŒæœŸåŠ¨æ€ drop
    - å¯ä»¥æœ‰ä¸åŒçš„ç”Ÿå‘½å‘¨æœŸ
- ä¸ `&'a T` ç›¸æ¯”ï¼Œ`T: 'a` æ›´é€šç”¨ã€æ›´çµæ´»
- `T: 'a` æ¥å—æ‹¥æœ‰æ‰€æœ‰æƒçš„ç±»å‹ï¼ˆå…¶å†…éƒ¨å¯å«æœ‰å¼•ç”¨ï¼‰ã€å¼•ç”¨ç±»å‹
- `&'a T` åªæ¥å—å¼•ç”¨ç±»å‹
- è‹¥ `T: 'static` åˆ™ `T: 'a` ï¼Œå› ä¸ºå¯¹äºæ‰€æœ‰ `'a` éƒ½æœ‰ `'static` >= `'a`
- å‡ ä¹æ‰€æœ‰ Rust ä»£ç éƒ½æ˜¯æ³›å‹ä»£ç ï¼Œå››å¤„çš†æ˜¯çœç•¥çš„ç”Ÿå‘½å‘¨æœŸæ³¨è§£
- Rust çš„å‡½æ•°ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™å¹¶ä¸æ€»æ˜¯é€‚ç”¨äºæ‰€æœ‰æƒ…å†µ
- Rust å¹¶ä¸æ¯”ä½ æ›´äº†è§£ç¨‹åºçš„è¯­ä¹‰
- ä¸ºç”Ÿå‘½å‘¨æœŸæ³¨è§£èµ‹äºˆæœ‰æ„ä¹‰çš„åç§°
- è°¨æ…è€ƒè™‘åœ¨ä½•å¤„æ”¾ç½®æ˜¾å¼ç”Ÿå‘½å‘¨æœŸæ³¨è§£ä»¥åŠä¸ºä»€ä¹ˆè¦è¿™æ ·åš
- æ‰€æœ‰ trait å¯¹è±¡éƒ½æœ‰éšå«çš„é»˜è®¤ç”Ÿå‘½å‘¨æœŸçº¦æŸ
- Rust é’ˆå¯¹ trait å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™å¹¶éé€‚åˆæ¯ç§æƒ…å†µ
- Rust ä¸ä¼šæ¯”ä½ æ›´äº†è§£ç¨‹åºçš„è¯­ä¹‰
- Rust ç¼–è¯‘å™¨é”™è¯¯ä¿¡æ¯æ‰€å»ºè®®çš„ä¿®å¤æ–¹æ³•å¯ä»¥ä½¿ç¨‹åºç¼–è¯‘æˆåŠŸï¼Œä½†è¿™å¹¶ä¸ç­‰åŒäºå¯ä»¥ä½¿ç¨‹åºç¼–è¯‘æˆåŠŸ _å¹¶ä¸”_ æœ€ç¬¦åˆè¦æ±‚ã€‚
- ç”Ÿå‘½å‘¨æœŸåœ¨ç¼–è¯‘æœŸè¿›è¡Œé™æ€éªŒè¯
- ç”Ÿå‘½å‘¨æœŸä¸èƒ½åœ¨è¿è¡ŒæœŸä»¥ä»»ä½•æ–¹å¼å¢é•¿ã€ç¼©çŸ­æˆ–æ”¹å˜
- Rust å€Ÿç”¨æ£€æŸ¥å™¨æ€»æ˜¯å‡å®šæ‰€æœ‰ä»£ç è·¯å¾„éƒ½ä¼šè¢«æ‰§è¡Œï¼Œç„¶åä¸ºå˜é‡é€‰æ‹©æœ€çŸ­çš„ç”Ÿå‘½å‘¨æœŸ
- å°½é‡é¿å…å°†å¯å˜å¼•ç”¨é‡æ–°å€Ÿç”¨ä¸ºå…±äº«å¼•ç”¨ï¼Œå¦åˆ™ä¼šè®©ä½ å¤´å¤§
- é‡æ–°å€Ÿç”¨å¯å˜å¼•ç”¨ä¸ä¼šç»“æŸå…¶ç”Ÿå‘½å‘¨æœŸï¼Œå³ä½¿è¯¥å¼•ç”¨å·²è¢« drop æ‰
- æ¯ç§è¯­è¨€çš†æœ‰é™·é˜± ğŸ¤·

---
åŸæ–‡ï¼š[Common Rust Lifetime Misconceptions](
https://github.com/pretzelhammer/rust-blog/blob/master/posts/common-rust-lifetime-misconceptions.md)<br/>è¯‘è€…ï¼šssbunnyï¼ˆå…”å­ä¸å’¬äººï¼‰